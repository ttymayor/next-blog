export const metadata = {
   title: '【資料結構】B-tree 到 B+ tree',
   description: '資料庫都在用的 B+ tree',
   pubDate: '2025-12-18T20:36:26+08:00',
   category: '資料結構',
   tags: ['Data Structure', 'Database', 'B-tree', 'B+ tree'],
   draft: false,
}

## 先備知識

電腦硬體設備資料讀取速度：`CPU` > `快取` > `RAM` > `固態硬碟（SSD）` > `傳統硬碟（HDD）`

1. 資料庫抓資料從`磁碟`讀取出來，因此我們希望一次可以讀取更多的資料，減少硬碟讀取頻率。
2. 當資料需要被修改處理時，通常進程會上鎖，避免其他進程同時修改同一筆資料，造成資料不一致。

## 先認識一下二元搜尋樹

![二元搜尋樹](https://tty-pic.zeabur.app/i/68a578f4-0d9c-4cbe-bdb9-5feb3d7677a1.png)

二元搜尋樹是一種特殊的二元樹，它的每個節點最多有兩個子節點，左子節點的值小於父節點的值，右子節點的值大於父節點的值。

## 二元搜尋樹的特點

1. 每個節點最多有兩個子節點
2. 左子節點的值小於父節點的值
3. 右子節點的值大於父節點的值

不適合用在資料庫，因為二元搜尋樹的深度過大，導致查詢效率低下。但通常在記憶體層中，二元搜尋樹的查詢效率還是可以接受的。

## B-tree

可以用 [btree.app](https://btree.app/) 來玩玩看 B-tree

![B-tree](https://tty-pic.zeabur.app/i/ba54b95e-7e6e-4469-91bd-889adc32e134.png)

### B-tree 的特點

1. 每層可以有很多 key
2. 子節點數量 = key 數量 + 1
3. 葉節點都在同一層（代表平衡）

### 解決了二元搜尋樹的問題

二元搜尋樹的深度（樹高）過大，導致查詢效率低下（因為每層都是一次查詢與比較），而 B-tree 的每層可以有很多 key，所以可以減少查詢次數，提高查詢效率。

換個角度想：
假設每一次從硬碟讀資料，就是「走下一層樹」。那：

- **二分搜尋樹**：一層只有一個 key，可以分兩邊 → 樹會長得很高，要讀很多次硬碟。
- **B-tree**：一層可以塞很多 key，一次讀取就能做很多區間的判斷 → 樹比較矮，硬碟 I/O 次數就變少。

所以 B-tree 的重點其實是「**把一個節點塞滿一整個硬碟 Page**」，讓每一次 I/O 的資訊量最大化。

## B-tree 搜尋流程

1. 從根節點開始，把該節點上的 key 依序掃過，比對要找的值在哪個區間。
2. 根據區間，走到對應的子節點。
3. 重複以上步驟，直到走到葉節點：
   - 找到 key → 回傳資料。
   - 找不到 → 回傳不存在。

可以把它想成「多路版本的二分搜尋樹」，只是每個節點不是 `2 個子樹`，而是 `M 個子樹（M-way Search Tree）`。

## B+ tree

可以用 [bplustree.app](https://bplustree.app/) 來玩玩看 B+ tree

![B+ tree](https://media.geeksforgeeks.org/wp-content/uploads/Btree.jpg)

### B+ tree 的特點

1. 只存 key 值，不存資料
2. 資料存放在葉節點中
3. 葉節點之間用指標連接

### 解決了 B-tree 的問題

上面說 B-tree 已經把樹弄得很矮了，那為什麼實務上資料庫更常用 B+ tree？

關鍵差異在於：

- **B-tree**：資料可以放在「內部節點」也可以放在「葉節點」。
- **B+ tree**：**資料只放在葉節點**，內部節點只存 key，當作索引用。

這樣做有幾個好處：

1. **所有查詢路徑長度一致**
   - 在 B-tree 中，有可能在「內部節點就直接命中資料」，也可能一路走到葉節點才找到。
   - B+ tree 的資料都在葉節點，所以所有查詢都會走到葉節點，**查詢成本比較穩定**。

2. **區間（範圍）查詢、排序非常方便**
   - 所有葉節點會用指標串成一條 linked list。
   - 例如要查 `[10, 100]` 這個範圍：
     1. 先用索引（內部節點）找到第一個 `>= 10` 的葉節點。
     2. 之後只要沿著葉節點指標往右一直走，讀到 `> 100` 就可以停了。
   - 這樣就避免了不必要的回頭查詢，也非常適合實作 `ORDER BY`、`BETWEEN`、`range scan`。

## B-tree vs B+ tree 比較

| 類型      | 資料位置           | 範圍查詢      | 查詢步驟長度 | 實務應用                    |
| --------- | ------------------ | ------------- | ------------ | --------------------------- |
| B-tree   | 內部 + 葉節點皆可 | 普通          | 不一定固定   | 理論說明 |
| B+ tree  | 只有葉節點         | **非常適合** | **固定到底** | 資料庫索引 |

所以從`二元搜尋樹`到 `B-tree` 再到 `B+ tree` 可以看到是越來越往資料庫的設計在延伸。

從樹太高的問題被 B-tree 解決，然後 B+ tree 在範圍查詢上做優化，最後 B+ tree 至今仍然是大多數資料庫選擇的結構。

## 參考

- [B-trees and database indexes](https://planetscale.com/blog/btrees-and-database-indexes)
